进程回顾：
程序：完成特定功能的一系列有序指令的集合
源代码--》可执行文件
代码段+数据段


进程：程序的一次动态执行的过程
代码段+数据段+堆栈段+进程控制块（PCB）  具有动态性

进程                          程序

动态的                       数据段
短暂的                       永久的
堆栈段+进程控制块（PCB）


一个进程只能对应一个程序

一个程序可以对应多个进程


线程：在一个程序里的执行路线就叫做线程，线程是一个进程内的控制序列
一切进程至少都有一个执行线程


进程：
进程是资源竞争的基本单位
线程是程序执行的最小单位
线程共享进程数据，但也拥有自己的一部分数据：
1、线程id
2、一组寄存器   ip  sp
3、栈
4、errno    不是共享的
5、信号状态
6、优先级  

4GB的地址空间是共享的


当一个进程执行一个fork调用时，会创建出进程的一个新拷贝，新进程将拥有自己的变量和它自己的pid，
这个新进程的运行时间是独立的，它在执行时几乎完全独立于创建它的进程


在进程里面创建一个新线程的时候，新的执行线程会拥有自己的堆栈（因此也有有自己的局部变量），
但要与它的创建者共享全局变量，文件描述符，信号处理器，和当前工作目录状态




线程调度竞争范围
1、进程竞争范围：各个线程在同一进程竞争cpu时间片，不直接和其他进程中的线程竞争
2、系统竞争范围：线程直接和系统范围内的其他线程竞争


三种线程模型

N:1用户线程模型   ----- 进程竞争范围
内核不干涉线程的任何生命活动，切换代价小，一个线程阻塞，所有的线程都会阻塞

1:1核心线程模型
用户线程和核心线程1：1  ---系统竞争范围
可以充分发挥多核处理器的并行性能,核心线程调度开销大

N:M混合线程模型
提供两级控制   用户线程--轻量级线程---核心线程
                  N           M           M
posix属于N:M混合线程模型




pid_t                thread_t
fork                 pthread_create   创建
waitpid	             pthread_join     等待

exit                 pthread_exit      退出
在main函数中调用      在线程入口函数中调用return    退出
return


僵尸进程             僵尸线程            
子进程结束，          新线程结束，二主线程没有调用pthread_join
父进程没有结束         也可调用pthread_detach  脱离主线程

kill                  pthread_cancel   


线程结束

自杀
pthread_exit ||
在线程入口函数中调用return

他杀
pthread_cancel

